import {
    app,
    BrowserWindow,
    ipcMain,
    dialog,
    Notification,
    shell
    // desktopCapturer,
    // session,
} from 'electron'
const { exec } = require('child_process')
import started from 'electron-squirrel-startup'
import { sendCommand, readCommand, readStatFile, clearStatFile } from './sendHyperCommands'
import { startSoloMode } from './loadFbNeo'
import { getConfig, type Config } from './config'
// updating automatically
import { updateElectronApp } from 'update-electron-app'
import { parseMatchData } from './utils/data'
// external api
import api from './external-api/requests'
// Emulator reference
let spawnedEmulator = null //used to handle closing the emulator process
let opponentUID = null
let lastKnownPlayerSlot = 0 // this is the player 1 or player 2 reference, used for tracking matches.
let currentMatchId = null // this is used by both players to upload matches, generated by the holepunching server.

// - FIREBASE AUTH CODE
import { initializeApp } from 'firebase/app'
import {
    getAuth,
    signInWithEmailAndPassword,
    signOut,
    createUserWithEmailAndPassword,
    signInWithCustomToken,
} from 'firebase/auth'
import { firebaseConfig } from './private/firebase'
import { TLogin } from './types'
import runProxyServer from './emulator/proxyServer'
import { timeStamp } from 'console'

// Initialize Firebase
const fbapp = initializeApp(firebaseConfig)

// Initialize Firebase Authentication and get a reference to the service
const auth = getAuth(fbapp)
// END FIREBASE

const fs = require('fs')
const path = require('path')

const isDev = !app.isPackaged

let userUID: string | null = null
let userName: string | null = null
let filePathBase = process.resourcesPath
const tokenFilePath = path.join(app.getPath('userData'), 'auth_token.json')

// USER LOGIN OBJECT GENERATION
const getLoginObject = (user: any) => {
    return {
        name: user.userName,
        email: user.userEmail,
        uid: user.uid,
        elo: user.accountElo || 0,
        userProfilePic: user.userProfilePic || 'test',
        userTitle: user.userTitle || null,
        lastKnownPings: user.lastKnownPings || null,
        countryCode: user.countryCode || null,
        winStreak: user.winStreak || 0,
    }
}

//handle dev mode toggle for file paths.
if (isDev) {
    filePathBase = path.join(app.getAppPath(), 'src')
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (started) {
    app.quit()
}

let mainWindow: BrowserWindow | null

// helpers
const sendLog = (text: string) => {
    // if (!mainWindow) return
    mainWindow.webContents.send('send-log', text)
}

async function autoUpdate() {
    console.log('initializing automatic updates')
    try {
        await updateElectronApp()
        console.log('starting update')
    } catch (error) {
        console.log('auto update failed with: ', err)
    }
}

const iconPath = isDev
    ? path.join(__dirname, '..', 'icons', 'favicon.ico')
    : path.join(process.resourcesPath, 'icons', 'favicon.ico')

const createWindow = () => {
    autoUpdate()
    // Create the browser window.
    mainWindow = new BrowserWindow({
        width: 1100,
        height: 700,
        backgroundColor: '#27272a',
        webPreferences: {
            nodeIntegration: true,
            preload: path.join(__dirname, 'preload.js'),
        },
        autoHideMenuBar: true,
        icon: iconPath
        // icon: './icons/favicon-32x32.png',
    })

    // allow for external link opening
    mainWindow.webContents.setWindowOpenHandler((details) => {
        require('electron').shell.openExternal(details.url)
        return { action: 'deny' }
    })

    // const overlayWindow = new BrowserWindow({
    //     width: 400,
    //     height: 200,
    //     frame: false,
    //     transparent: true,
    //     alwaysOnTop: true,
    //     focusable: false,
    //     skipTaskbar: true,
    //     hasShadow: false,
    //     resizable: false,
    //     fullscreenable: false,
    //     webPreferences: {
    //         nodeIntegration: true,
    //         contextIsolation: false,
    //     },
    // })

    // overlayWindow.setIgnoreMouseEvents(true) // Allows clicks to go through
    // overlayWindow.loadURL('file://' + __dirname + '/overlay.html')

    // TODO this is for screen share, just for testing, but possible for other features in the future.
    // session.defaultSession.setDisplayMediaRequestHandler(
    //     (request, callback) => {
    //         desktopCapturer.getSources({ types: ['screen'] }).then((sources) => {
    //             // Grant access to the first screen found.
    //             // callback({ video: sources[0], audio: 'loopback' })
    //             callback({ video: sources[0] })
    //         })
    //         // If true, use the system picker if available.
    //         // Note: this is currently experimental. If the system picker
    //         // is available, it will be used and the media request handler
    //         // will not be invoked.
    //     },
    //     { useSystemPicker: true }
    // )

    let config: Config

    function getConfigData() {
        try {
            config = getConfig()
        } catch (error) {
            mainWindow.webContents.send('message-from-main', error)
            console.error('Failed to read file:', error)
        }
    }

    getConfigData() // get the config on boot.

    // show dev tools
    //mainWindow.webContents.openDevTools()

    ipcMain.on('openEmulatorFolder', async () => {
        const externalAppPath = path.join(process.resourcesPath, 'emu/hyper-screw-fbneo/roms');
        try {
            await shell.openPath(externalAppPath);
        } catch (error) {
            new Notification({
                title: 'Error',
                body: 'Rom folder does not exist'
            }).show()
        }

    })

    const setEmulatorPath = async (isResetPath = false) => {
        // the below path is only for the default emulator settings
        const externalAppPath = path.join(process.resourcesPath, 'emu/hyper-screw-fbneo');
        if (isResetPath) {
            const filePath = path.join(filePathBase, 'config.txt')
            mainWindow.webContents.send(
                'message-from-main',
                `reset file path`
            )

            // Read the existing file
            let fileContent = fs.existsSync(filePath)
                ? fs.readFileSync(filePath, 'utf8')
                : ''

            // Split the file into lines
            let lines = fileContent.split('\n')

            // Find and update the delay line
            let found = false
            lines = lines.map((line: string) => {
                if (line.startsWith('emuPath=')) {
                    found = true
                    return `emuPath=${externalAppPath}` // Replace the file path line

                }
                return line // Keep other lines the same
            })

            // If no emuPath= line exists, append it with the default path
            if (!found) {
                if (isResetPath) {
                    lines.push(`emuPath=${externalAppPath}`)
                }
            }

            // Write back the modified content
            fs.writeFileSync(filePath, lines.join('\n'), 'utf8')
            getEmulatorPath()
            return
        }

        try {
            await dialog
                .showOpenDialog({ properties: ['openFile', 'openDirectory'] })
                .then((res) => {
                    if (res.canceled || !res.filePaths.length) return
                    try {
                        const filePath = path.join(filePathBase, 'config.txt')
                        mainWindow.webContents.send(
                            'message-from-main',
                            `Set emulator filepath to: ${res.filePaths[0]}`
                        )

                        // Read the existing file
                        let fileContent = fs.existsSync(filePath)
                            ? fs.readFileSync(filePath, 'utf8')
                            : ''

                        // Split the file into lines
                        let lines = fileContent.split('\n')

                        // Find and update the delay line
                        let found = false
                        lines = lines.map((line: string) => {
                            if (line.startsWith('emuPath=')) {
                                found = true
                                return `emuPath=${res.filePaths[0]}` // Replace the file path line
                            }
                            return line // Keep other lines the same
                        })

                        // If no emuPath= line exists, append it with the default path
                        if (!found) {
                            lines.push(`emuPath=${res.filePaths[0]}`)
                        }

                        // Write back the modified content
                        fs.writeFileSync(filePath, lines.join('\n'), 'utf8')
                        getEmulatorPath()
                    } catch (error) {
                        mainWindow.webContents.send('message-from-main', error)
                        console.error('Failed to write to config file:', error)
                        return 'Failed to write to config file'
                    }
                })
                .catch((err) => console.log(err))
        } catch (error) {
            console.log(error)
        }
    }

    // This will happen on load
    if (!config.app.emuPath) {
        setEmulatorPath(true)
        // We don't necessarily need this warning because it should default the path now.
        // new Notification({
        //     title: 'error',
        //     body: 'incorrect file path for your emulator',
        // }).show()
    }


    const getEmulatorPath = async () => {
        await getConfigData()
        console.log('EMULATOR PATH = ', config.app.emuPath)
        mainWindow.webContents.send('emulatorPath', config.app.emuPath)
    }

    const setEmulatorDelay = async (delayNum: number) => {
        console.log('attempting set delay', delayNum)
        try {
            const filePath = path.join(filePathBase, 'config.txt')
            mainWindow.webContents.send('message-from-main', `Set emulator delay to: ${delayNum}`)

            // Read the existing file
            let fileContent = fs.existsSync(filePath) ? fs.readFileSync(filePath, 'utf8') : ''

            // Split the file into lines
            let lines = fileContent.split('\n')

            // Find and update the delay line
            let found = false
            lines = lines.map((line: string) => {
                if (line.startsWith('emuDelay=')) {
                    found = true
                    return `emuDelay=${delayNum}` // Replace the delay line
                }
                return line // Keep other lines the same
            })

            // If no emuDelay= line exists, append it
            if (!found) {
                lines.push(`emuDelay=${delayNum}`)
            }

            // Write back the modified content
            fs.writeFileSync(filePath, lines.join('\n'), 'utf8')

            console.log(`CONFIG: Updated delay to ${delayNum}`)
        } catch (error) {
            mainWindow.webContents.send('message-from-main', error)
            console.error('Failed to write to config file:', error)
        }
    }

    const getEmulatorDelay = async () => {
        await getConfigData()
        console.log('EMULATOR DELAY = ', config.app.emuDelay)
        mainWindow.webContents.send('emulatorDelay', config.app.emuDelay)
    }

    const setAppTheme = async (themeIndex: number) => {
        console.log('attempting set theme', themeIndex)
        try {
            const filePath = path.join(filePathBase, 'config.txt')
            mainWindow.webContents.send('message-from-main', `Set emulator theme to: ${themeIndex}`)

            // Read the existing file
            let fileContent = fs.existsSync(filePath) ? fs.readFileSync(filePath, 'utf8') : ''

            // Split the file into lines
            let lines = fileContent.split('\n')

            // Find and update the theme line
            let found = false
            lines = lines.map((line: string) => {
                if (line.startsWith('appTheme=')) {
                    found = true
                    return `appTheme=${themeIndex}`
                }
                return line
            })

            if (!found) {
                lines.push(`appTheme=${themeIndex}`)
            }

            // Write back the modified content
            fs.writeFileSync(filePath, lines.join('\n'), 'utf8')

            console.log(`CONFIG: Updated delay to ${themeIndex}`)
        } catch (error) {
            mainWindow.webContents.send('message-from-main', error)
            console.error('Failed to write to config file:', error)
        }
    }

    const setConfigValue = async (key: string, value: string | number) => {
        console.log(`Attempting to set config ${key} = ${value}`)

        try {
            const filePath = path.join(filePathBase, 'config.txt')
            mainWindow.webContents.send('message-from-main', `Set config ${key} to: ${value}`)

            let fileContent = fs.existsSync(filePath)
                ? fs.readFileSync(filePath, 'utf8').replace(/\r\n/g, '\n')
                : ''
            let lines = fileContent
                .split('\n')
                .filter(line => line.trim() !== '')

            let found = false
            lines = lines.map((line: string) => {
                if (line.startsWith(`${key}=`)) {
                    found = true
                    return `${key}=${value}`
                }
                return line
            })

            if (!found) {
                lines.push(`${key}=${value}`)
            }

            fs.writeFileSync(filePath, lines.join('\n'), 'utf8')

            console.log(`CONFIG: Updated ${key} to ${value}`)
        } catch (error) {
            mainWindow.webContents.send('message-from-main', `Error updating ${key}: ${error}`)
            console.error(`Failed to update config ${key}:`, error)
        }
    }

    const getConfigValue = async (key: string) => {
        await getConfigData() // Ensures latest config is loaded

        // Access value safely, assuming config is flat or nested as needed
        const value = config[key] ?? config.app?.[key]
        console.log('Got a config value', key, value)

        mainWindow.webContents.send('getConfigValue', { key, value })
    }

    const getAppTheme = async () => {
        await getConfigData()
        mainWindow.webContents.send('appTheme', parseInt(config.app.appTheme))
    }

    // firebase login
    async function handleLogin({ email, pass }: TLogin) {
        try {
            await signInWithEmailAndPassword(auth, email, pass)
                .then(async (data) => {
                    await saveRefreshToken(data.user.refreshToken)
                    return true
                })
                .catch((error) => {
                    const errorCode = error.code
                    const errorMessage = error.message
                    console.log('failed to log in', errorCode, errorMessage)
                    mainWindow.webContents.send('login-failed', 'login failed')
                })
        } catch (error) {
            console.log(error)
        }
    }

    async function saveRefreshToken(refreshToken: string) {
        await fs.writeFileSync(tokenFilePath, JSON.stringify({ refreshToken }), {
            encoding: 'utf-8',
        })
    }

    async function removeRefreshToken() {
        await fs.unlinkSync(tokenFilePath, 'auth_token.json')
    }

    async function handleLogOut() {
        await signOut(auth)
            .then(() => {
                try {
                    removeRefreshToken()
                    mainWindow.webContents.send('loggedOutSuccess', 'user logged out')
                } catch (error) {
                    console.log('sending signal to fe to log out')
                }
            })
            .catch((error) => {
                console.log('user logging out failed', error)
            })
    }

    async function startLoginProcess(login: TLogin) {
        const loginObject = await api
            .getLoggedInUser(login.email)
            .catch((err) => console.log('error checkig if user was loggin in', err))
        if (loginObject && loginObject.loggedIn) {
            // user is already logged in, handle relog
            console.log('user was already logged in', loginObject)
            await handleLogOut()
        }
        await handleLogin({ email: login.email, pass: login.pass }).catch((err) =>
            console.log('failed to log in')
        )
        await api
            .addLoggedInUser(auth)
            .catch((err) => console.log('failed to add user to logged in users list'))
        //test first time log

        const user = await api
            .getUserByAuth(auth)
            .catch((err) => console.log('err getting user by auth'))
        if (user) {
            // send our user object to the front end
            mainWindow.webContents.send('loginSuccess', getLoginObject(user))
            userUID = user.uid
            console.log('setting user ', user.name, user)
            userName = user.name
            console.log('user is: ', user)
        }
    }

    // handle ipc calls
    ipcMain.on('loginUser', async (event, login) => {
        // this line seems to fail on mac??
        await startLoginProcess(login).catch((err) => console.log(err))
    })

    ipcMain.on('createAccount', async (event, info) => {
        await createUserWithEmailAndPassword(auth, info.email, info.pass)
            .then((userCredential) => {
                console.log('creating new account for user', info.email)
                const user = userCredential.user
                // account created successfully, send message to FE
                mainWindow.webContents.send('accountCreationSuccess')
            })
            .catch((error) => {
                const errorCode = error.code
                const errorMessage = error.message
                console.log('error adding user', info.email, error.code, error.message)
                // account creation failed, send message to FE
                return mainWindow.webContents.send('accountCreationFailure')
            })
        await api
            .createAccount(auth, info.name, info.email)
            .catch((err) => console.log('failed to create new account'))
        await startLoginProcess(info).catch((err) => console.log(err))
    })

    ipcMain.on('logOutUser', async (event, login) => {
        console.log('should log out user', userUID)
        await api.removeLoggedInUser(auth).catch((err) => console.log(err))
        await handleLogOut().catch((err) => console.log(err))
    })

    ipcMain.on('getLoggedInUser', async (event, uid) => {
        const isLoggedIn = await api.getLoggedInUser(uid).catch((err) => console.log(err))
        return isLoggedIn
    })

    // Web RTC stuff
    ipcMain.on('hand-shake-users', (event, type) => {
        mainWindow.webContents.send('hand-shake-users', type)
    })

    ipcMain.on('send-data-channel', (event, data) => {
        mainWindow.webContents.send('send-data-channel', data)
    })

    ipcMain.on('setEmulatorPath', (event, isResetPath) => {
        setEmulatorPath(isResetPath)
    })

    ipcMain.on('getEmulatorPath', () => {
        getEmulatorPath()
    })

    ipcMain.on('setEmulatorDelay', (event, delay) => {
        setEmulatorDelay(delay)
    })

    ipcMain.on('getEmulatorDelay', () => {
        getEmulatorDelay()
    })

    ipcMain.on('setAppTheme', (event, themeIndex) => {
        setAppTheme(themeIndex)
    })

    //TODO make the config setters use this instead
    ipcMain.on('setConfigValue', (event, { key, value }) => {
        setConfigValue(key, value)
        if (key === 'isAway') {
            mainWindow.webContents.send('updateSocketState', { key, value })
        }
    })

    ipcMain.on('getConfigValue', (event, { key }) => {
        getConfigValue(key)
        if (key === 'isAway') {
            mainWindow.webContents.send('updateSocketState', {
                key,
                value: config?.app?.isAway || 'false',
            })
        }
    })

    ipcMain.on('getAppTheme', () => {
        getAppTheme()
    })

    // receives text from front end sends it to emulator
    ipcMain.on('send-text', (event, text: string) => {
        sendCommand(`textinput:${text}`)
        // test functions
        readStatFile(mainWindow)
    })

    ipcMain.on('serveMatch', async (event, data) => { })

    ipcMain.on('startGameOnline', async (event, data) => {
        console.log('Starting proxer server for matches')
        lastKnownPlayerSlot = data.player // set the last know player slot for sending to the BE to record matches
        runProxyServer(data, userUID, userName, config, mainWindow)
    })

    function killProcessByName(processName) {
        exec(`taskkill /F /IM ${processName}`, (error, stdout, stderr) => {
            if (error) {
                console.error(`Failed to kill ${processName}: ${error.message}`)
                return
            }
            console.log(`${processName} killed successfully:\n${stdout}`)
        })
    }

    ipcMain.on('killEmulator', async () => {
        await mainWindow.webContents.send(
            'message-from-main',
            'Attempting to gracefully close emulator'
        );

        if (spawnedEmulator) {
            const pid = spawnedEmulator.pid;
            console.log('Attempting to terminate emulator, PID:', pid);

            spawnedEmulator.on('close', (code, signal) => {
                console.log(`Emulator process closed. Code: ${code}, Signal: ${signal}`);
                spawnedEmulator = null;
            });

            try {
                spawnedEmulator.kill('SIGTERM');
            } catch (e) {
                console.error('Error sending SIGTERM:', e);
            }

            setTimeout(() => {
                if (spawnedEmulator) {
                    console.warn('Process still alive after 2s. Forcing SIGKILL...');
                    try {
                        spawnedEmulator.kill('SIGKILL');
                    } catch (e) {
                        console.error('Failed to SIGKILL:', e);
                    }
                }
            }, 2000);

            if (process.platform === 'win32') {
                exec(`taskkill /PID ${pid} /F /T`, (err, stdout, stderr) => {
                    if (err) {
                        console.error(`taskkill failed for PID ${pid}:`, err);
                    } else {
                        console.log(`taskkill succeeded for PID ${pid}`);
                    }
                });

                const pathEnd = config.emulator.fbNeoPath
                const slicedPathEnd = pathEnd && pathEnd.split('\\').pop()

                if (slicedPathEnd === 'fs-fbneo.exe') {
                    killProcessByName('fs-fbneo.exe');
                } else if (slicedPathEnd === 'fcadefbneo.exe') {
                    killProcessByName('fcadefbneo.exe');

                }

            }

            await mainWindow.webContents.send('message-from-main', 'Emulator exists, closing');
        } else {
            console.log('No emulator process found to kill.');
        }

        // killSocketAndEmu();
        clearStatFile();
        mainWindow.webContents.send('endMatchUI', userUID);
    });

    // ipcMain.on('killEmulator', async () => {
    //     killSocketAndEmu()

    //     await mainWindow.webContents.send(
    //         'message-from-main',
    //         'Attempting to gracefully close emulator'
    //     )

    //     try {
    //         if (spawnedEmulator) {
    //             console.log('Trying to close emulator', spawnedEmulator.pid)

    //             // Try SIGTERM first
    //             spawnedEmulator.kill('SIGTERM')
    //             // if we are on windows we also need to kill the process

    //             // Listen for the process to close
    //             spawnedEmulator.on('close', (code, signal) => {
    //                 console.log(`Emulator exited with code ${code} and signal ${signal}`)
    //                 spawnedEmulator = null
    //             })

    //             // After 2 seconds, force kill if it's still running
    //             setTimeout(() => {
    //                 if (spawnedEmulator && !spawnedEmulator.killed) {
    //                     console.log('Force killing emulator')
    //                     spawnedEmulator.kill('SIGKILL')
    //                 }
    //             }, 2000)

    //             if (process.platform === 'win32') {
    //                 console.log('trying to kill the emulator here')
    //                 // killProcessByName('fcadefbneo.exe')
    //                 killProcessByName('fs-fbneo.exe')
    //                 spawnedEmulator = null
    //             }

    //             mainWindow.webContents.send('message-from-main', 'Emulator exists, closing')
    //         }
    //     } catch (err) {
    //         mainWindow.webContents.send('message-from-main', 'Could not close emulator')
    //         console.error('Failed to close emulator:', err)
    //     }

    //     // Check if process is still alive before calling taskkill
    //     if (spawnedEmulator) {
    //         const pid = spawnedEmulator.pid
    //         console.log('emulator', pid)

    //         // Debug: Check if process is still running
    //         exec(`tasklist /FI "PID eq ${pid}"`, (err, stdout, stderr) => {
    //             if (!stdout.includes(pid)) {
    //                 console.log(`Process ${pid} is already gone.`)
    //                 return
    //             }

    //             console.log(`Process ${pid} is still running. Attempting to force kill...`)

    //             if (process.platform === 'win32') {
    //                 exec(`taskkill /PID ${pid} /F`, (err, stdout, stderr) => {
    //                     if (err) console.error('taskkill failed:', err)
    //                 })
    //             } else {
    //                 exec(`pkill -P ${pid}`, (err, stdout, stderr) => {
    //                     if (err) console.error('pkill failed:', err)
    //                 })
    //             }
    //         })
    //     }

    //     // Cleanup
    //     spawnedEmulator = null
    //     clearStatFile()
    //     mainWindow.webContents.send('endMatchUI', userUID)
    // })

    ipcMain.on('startTrainingMode', (event) => {
        startSoloMode({
            config,
            callBack: (isOnOpen) => {
                console.log('emulator force closed')
                mainWindow.webContents.send('endMatchUI', userUID)
                mainWindow.webContents.send('endMatch', userUID)
                if (isOnOpen) {
                    mainWindow.webContents.send('sendAlert', {
                        type: 'error',
                        message: {
                            title: 'Emulator failed to open.',
                            description: 'Failed to open emulator, please check your path',
                        },
                    })
                }
            },
        })
    })

    // send a message off to websockets for other users to see and save our message on our front end.
    ipcMain.on('sendMessage', (event, messageObject: { text: string; user: any }) => {
        // here we can parse the string etc
        console.log('Main process received message:', messageObject)
        mainWindow.webContents.send('sendMessage', messageObject)
    })

    ipcMain.on(
        'createNewLobby',
        (event, lobbyData: { name: string; pass: string; user: any; isPrivate: boolean }) => {
            mainWindow.webContents.send('createNewLobby', lobbyData)
        }
    )

    ipcMain.on('updateLobbyStats', (event, lobbyArray: any) => {
        mainWindow.webContents.send('updateLobbyStats', lobbyArray)
    })

    ipcMain.on('updateUserData', (event, data: any) => {
        mainWindow.webContents.send('updateUserData', data)
    })

    ipcMain.on(
        'userChangeLobby',
        (event, lobbyData: { newLobbyId: string; pass: string; user: any; isPrivate: boolean }) => {
            console.log('lobby changing', lobbyData)
            mainWindow.webContents.send('userChangeLobby', lobbyData)
        }
    )

    // this is used by websockets to populate our chat room with other peoples messages
    ipcMain.on('sendRoomMessage', async (event, messageObject) => {
        mainWindow.webContents.send('sendRoomMessage', messageObject)
    })

    ipcMain.on('getChallengeQueue', async (event, messageObject) => {
        mainWindow.webContents.send('getChallengeQueue', messageObject)
    })

    // add a user to the current chat room
    ipcMain.on('addUserToRoom', (event, userObject) => {
        mainWindow.webContents.send('room-users-add', userObject)
    })

    // remove user from the current chat room
    ipcMain.on('removeUserFromRoom', (event, userObject) => {
        mainWindow.webContents.send('room-users-remove', userObject)
    })

    ipcMain.on('addUserGroupToRoom', (event, users) => {
        mainWindow.webContents.send('room-users-add-group', users)
    })

    // PROFILE RELATED IPC CALLS
    ipcMain.on('changeUserData', async (event, userData) => {
        console.log('trying to change user data', userData)
        const complete = await api.updateUserData(auth, userData).catch((err) => console.log(err))
        console.log('data from api', complete)
        // mainWindow.webContents.send('user-account-changed', complete)
    })

    ipcMain.on('getUserMatches', async (event, { userId, lastMatchId, firstMatchId }) => {
        const setOfMatchesPaginated = await api
            .getUserMatches(auth, userId, lastMatchId, firstMatchId)
            .catch((err) => console.log(err))

        mainWindow.webContents.send('getUserMatches', setOfMatchesPaginated)
    })

    ipcMain.on('getGlobalSet', async (event, { userId, matchId }) => {
        const matches = await api
            .getGlobalSet(auth, userId, matchId)
            .catch((err) => console.log(err))
        if (!matches) {
            mainWindow.webContents.send('sendAlert', {
                type: 'error',
                message: {
                    title: 'Failed to load Match Set.',
                },
            })
        }
        mainWindow.webContents.send('fillGlobalSet', matches)
    })

    ipcMain.on('getAllTitles', async (event, { userId }) => {
        const matches = await api.getAllTitles(auth, userId).catch((err) => console.log(err))
        mainWindow.webContents.send('fillAllTitles', matches)
    })

    ipcMain.on('getUserData', async (event, userId) => {
        const userData = await api.getUserData(auth, userId).catch((err) => console.log(err))
        const playerStats = await api.getPlayerStats(auth, userId).catch((err) => console.log(err))
        console.log('user data', { ...userData, ...playerStats })
        mainWindow.webContents.send('getUserData', { ...userData, ...playerStats })
    })

    ipcMain.on('getGlobalStats', async (event, { userId }) => {
        const globalStats = await api.getGlobalStats(auth, userId).catch((err) => console.log(err))
        console.log('global stats', globalStats)
        mainWindow.webContents.send('fillGlobalStats', globalStats)
    })

    // matchmaking
    ipcMain.on('callUser', (event, data) => {
        console.log(data)
        mainWindow.webContents.send('callUser', data)
    })

    ipcMain.on('answerCall', (event, data) => {
        console.log(data)
        mainWindow.webContents.send('answerCall', { ...data, answererId: userUID })
    })

    ipcMain.on('declineCall', (event, data) => {
        console.log('call is being declined in main')
        mainWindow.webContents.send('declineCall', data)
    })

    ipcMain.on('callDeclined', (event, data) => {
        console.log('our call was declined')
        mainWindow.webContents.send('callDeclined', data)
    })

    ipcMain.on('receivedCall', (event, data) => {
        console.log(data)
        mainWindow.webContents.send('receivedCall', data)
        const challengeObject = {
            sender: data.from,
            message: 'got a challenge',
            type: 'challenge',
            declined: false,
            accepted: false,
            id: Date.now(), // TODO this is not a long lasting solution
        }
        mainWindow.webContents.send('sendRoomMessage', challengeObject)
        mainWindow.webContents.send('getChallengeQueue', challengeObject)
    })

    // and load the index.html of the app.
    if (MAIN_WINDOW_VITE_DEV_SERVER_URL) {
        mainWindow.loadURL(MAIN_WINDOW_VITE_DEV_SERVER_URL)
    } else {
        mainWindow.loadFile(path.join(__dirname, `../renderer/${MAIN_WINDOW_VITE_NAME}/index.html`))
    }

    // handle cleanup on closing window
    mainWindow.on('close', async (event) => {
        console.log('closing app as', userUID)
        setTimeout(() => {
            mainWindow?.destroy() // force window to close when we finish
        }, 500)
        event.preventDefault()
    })
}

async function handleExitApp() {
    if (userUID) {
        // remove user from websockets and log them out of firebase on close
        await api.removeLoggedInUser(auth)
        // await killUdpSocket()
        // mainWindow?.webContents.send('closingApp', { uid: userUID })
    }
    // if (proxyListener) {
    //     console.log('closing proxy server')
    //     await proxyListener.close()
    //     proxyListener = null
    // }
    // if (upnpClient) {
    //     // TODO fix this
    //     // this request is causing a lot of issues
    //     // await upnpClient
    //     //     .portUnmapping({ public: portForUPNP }, (err) => {
    //     //         if (!err) return
    //     //         console.log('failed to close port', err)
    //     //     })
    //     //     .catch((err) => console.log(err))
    //     setTimeout(() => {
    //         upnpClient.close()
    //     }, 500)
    // }
}

// Listen for a request and respond to it
ipcMain.on('request-data', (event) => {
    event.sender.send('response-data', {
        msg: 'Here is some data from ipcMain',
    })
})

// we'll use this as a guard to make sure we don't re-upload the same match over and over.

let lastKnownMatch = null
async function handleReadAndUploadMatch() {
    // TODO major issues sending repeated data.
    const data = await readCommand()
    if (!data) return
    // remove below code
    if (!currentMatchId) {
        currentMatchId = 'dev-matches-and-bugs'
    }
    if (data && data.length && currentMatchId) {
        //send match data to back end
        // console.log('we got some match data, sending it to the BE')
        const matchData = {
            matchData: {
                raw: data,
            },
            matchId: currentMatchId, // match id generated by the hole punching server
            player1: lastKnownPlayerSlot == 0 ? userUID : opponentUID || 'fake-user',
            player2: lastKnownPlayerSlot == 1 ? userUID : opponentUID || 'fake-user',
        }
        const parsedMatch = parseMatchData(data)
        // prevent dupe uploads
        if (parsedMatch?.['match-uuid'] === lastKnownMatch?.['match-uuid']) {
            console.log('Duplicate found, cannot upload uuid match')
        }
        if (lastKnownMatch === parsedMatch) {
            // We should probably use some kind of unique id per match just to ensure that a match is always 
            return console.log("Unable to upload duplicate match, exact data")
        }
        if (lastKnownMatch === null) {
            lastKnownMatch = parsedMatch
        }

        // Update win streak or local UI data after a match.
        // Users could potentially fudge this data but thats ok for now.
        if (matchData.player1 === userUID) {
            if (parsedMatch?.['p1-win']) {
                console.log('streak increased')
                mainWindow.webContents.send('updateSocketState', {
                    key: 'winStreak',
                    value: 1,
                })
            } else {
                console.log('streak lost')
                mainWindow.webContents.send('updateSocketState', {
                    key: 'winStreak',
                    value: 0,
                })
            }
        }

        await api.uploadMatchData(auth, matchData)
    }
}

// read files
const readInterval = setInterval(async () => {
    // uncomment if testing locally and need matches to upload
    if (opponentUID) {
        handleReadAndUploadMatch()
    }
}, 1000) // read from reflector.text every 1000 ms

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow)

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', async () => {
    if (readInterval) {
        clearInterval(readInterval)
    }
    await handleExitApp()
    if (process.platform !== 'darwin') {
        app.quit()
    }
})

// app.on('before-quit', async () => {
//     console.log('app trying to quit')
// })

process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Promise Rejection:', reason)
})

process.on('SIGINT', async () => {
    await handleExitApp()
    console.log('SIGINT received (CTRL+C or process kill)')
    app.quit()
})

process.on('SIGTERM', async () => {
    await handleExitApp()
    console.log('SIGTERM received (system shutdown or process termination)')
    app.quit()
})

app.on('activate', () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow()
    }
})

app.whenReady().then(async () => {
    mainWindow.webContents.once('did-finish-load', () => {
        mainWindow.webContents.send('autoLoggingIn')
        function getRefreshToken() {
            if (fs.existsSync(tokenFilePath)) {
                const data = JSON.parse(fs.readFileSync(tokenFilePath, 'utf-8'))
                return data.refreshToken
            }
            console.log('failed to get refresh token')
            mainWindow.webContents.send('autoLoginFailure')
            return null
        }
        // mainWindow.webContents.send('ui-ready'); // You can send an event to renderer if needed
        async function startAutoLoginProcess() {
            // lets check if we have a refresh token first, if we do lets auto log in users that are opted in.
            const token = await getRefreshToken()
            if (token) {
                // console.log('We should auto log in', token)
                const loginData = await api.autoLogin(token)
                const customToken = await api
                    .getCustomToken(loginData.id_token)
                    .then((res) => res)
                    .catch((err) => console.log(err))
                // console.log('auto logged in', customToken)
                await signInWithCustomToken(auth, customToken)
                const user = await api
                    .getUserByAuth(auth)
                    .catch((err) => console.log('err getting user by auth'))

                if (user) {
                    // send our user object to the front end
                    mainWindow.webContents.send('loginSuccess', getLoginObject(user))
                    userUID = user.uid
                    userName = user.userName
                    console.log('user is: ', user) // used to observe initial user state
                }
            } else {
                mainWindow.webContents.send('autoLoginFailure')
                return console.log('User needs to log in.')
            }
        }

        startAutoLoginProcess()
    })
})
